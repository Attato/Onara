import React, { useState } from 'react';

import fs from 'fs/promises';
import path from 'path';
import matter from 'gray-matter';

import { GetStaticPaths, GetStaticProps } from 'next';
import Head from 'next/head';
import Link from 'next/link';
import { usePathname } from 'next/navigation';

import { MDXRemote } from 'next-mdx-remote';
import { serialize } from 'next-mdx-remote/serialize';
import { MDXProvider } from '@mdx-js/react';

import SideBar from '@/components/Sidebar';
import NavLinks from '@/components/NavLinks';
import BurgerMenu from '@/components/BurgerMenu';
import IconWrapper from '@/components/IconWrapper';

// Для использования в mdx файлах
import CodeBlock from '@/components/CodeBlock';

import styles from './index.module.scss';
import { NextPage } from 'next/types';

interface PostData {
	[key: string]: any;
}

export interface Post {
	slug: string;
	frontMatter: PostData;
}

interface SlugPageProps {
	mdxSource: any;
	frontMatter: PostData;
	allPosts: Post[];
}

const getPosts = async (): Promise<Post[]> => {
	// Get the path to the directory containing the MDX files
	const mdxFilesDirectory = path.join(process.cwd(), 'posts/docs');
	const mdxFiles = await fs.readdir(mdxFilesDirectory);

	const posts = await Promise.all(
		mdxFiles.map(async (file) => {
			const slug = file.replace(/\.mdx$/, '');
			const { data: frontMatter } = await getMdxFileContent(slug);
			return { slug, frontMatter };
		})
	);

	return posts;
};

const getMdxFileContent = async (slug: string) => {
	const mdxFilePath = path.join(process.cwd(), `posts/docs/${slug}.mdx`);
	const fileContents = await fs.readFile(mdxFilePath, 'utf-8');
	const { content, data } = matter(fileContents);

	const fileStats = await fs.stat(mdxFilePath);
	const lastUpdated = new Date(fileStats.mtime).toLocaleDateString();

	return { content, data: { ...data, lastUpdated } };
};

const components = {
	CodeBlock,
};

const SlugPage: NextPage<SlugPageProps> = ({
	mdxSource,
	frontMatter,
	allPosts,
}) => {
	const [isBurgerMenuOpen, setIsBurgerMenuOpen] = useState<boolean>(false);

	const closeBurgerMenu = () => {
		setTimeout(() => {
			setIsBurgerMenuOpen(!isBurgerMenuOpen);
		}, 100);
	};

	const formattedDate = new Date(frontMatter.lastUpdated).toLocaleDateString(
		'en-US',
		{
			year: 'numeric',
			month: 'long',
			day: 'numeric',
		}
	);

	const pathname = usePathname();

	// Sidebar logic
	const sortedPosts = [...allPosts].sort(
		(a, b) => a.frontMatter.id - b.frontMatter.id
	);

	const categories = sortedPosts.reduce((categories, post) => {
		const category = post.frontMatter.category;
		const isActive = pathname === `/docs/${post.slug}`;

		categories[category] = categories[category] || [];
		categories[category].push(
			<Link
				key={post.slug}
				href={`/docs/${post.slug}`}
				className={isActive ? styles.activeLink : ''}
			>
				{post.frontMatter.title}
			</Link>
		);

		return categories;
	}, {} as { [category: string]: JSX.Element[] });

	return (
		<>
			<Head>
				<title>{frontMatter.title}</title>
				<meta name="description" content="Generated by create next app" />
				<link rel="icon" href="/icon.svg" />
			</Head>

			<div className={styles.docs}>
				<div className="main">
					<div className={styles.slug}>
						<SideBar posts={allPosts} />
						<BurgerMenu
							isBurgerMenuOpen={isBurgerMenuOpen}
							closeBurgerMenu={closeBurgerMenu}
							title={
								<React.Fragment>
									{allPosts
										.filter((post) => `/docs/${post.slug}` === pathname)
										.map((post) => {
											return (
												<div key={post.slug} className={styles.breadcrumb}>
													{post.frontMatter.category}{' '}
													<IconWrapper width={14} height={14}>
														<path
															strokeLinecap="round"
															strokeLinejoin="round"
															d="M8.25 4.5l7.5 7.5-7.5 7.5"
														/>
													</IconWrapper>
													<span>{post.frontMatter.title}</span>
												</div>
											);
										})}
								</React.Fragment>
							}
						>
							{Object.entries(categories).map(([category, links]) => (
								<div key={category} className={styles.burgerMenu_category}>
									<h4 className={styles.burgerMenu_category_title}>
										{category}
									</h4>

									<div className={styles.burgerMenu_links}>{links}</div>
								</div>
							))}
						</BurgerMenu>

						<div className={styles.page_content}>
							<div className={styles.time_info}>
								<span>{formattedDate}</span>
								<span> 1 min read</span>
							</div>

							<MDXProvider components={components}>
								<MDXRemote {...mdxSource} />
							</MDXProvider>

							<NavLinks posts={allPosts} />
						</div>
					</div>
				</div>
			</div>
		</>
	);
};

export const getStaticPaths: GetStaticPaths = async () => {
	const mdxFilesDirectory = path.join(process.cwd(), 'posts/docs');
	const mdxFiles = await fs.readdir(mdxFilesDirectory);

	const paths = mdxFiles.map((file) => ({
		params: { slug: file.replace(/\.mdx$/, '') },
	}));

	return { paths, fallback: false };
};

export const getStaticProps: GetStaticProps = async ({ params }) => {
	const { slug }: any = params;
	const { content, data: frontMatter } = await getMdxFileContent(
		slug as string
	);
	const mdxSource = await serialize(content);
	const allPosts = await getPosts();

	return { props: { mdxSource, frontMatter, allPosts } };
};

export default SlugPage;
